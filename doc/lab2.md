# Lab 2 - Allocator

在本实验中，我们将管理系统中的物理内存，实现物理内存分配器供后续代码使用，并开始考虑并发安全问题。

## Updates

我们对lab1中部分代码进行了补正。

* 在`common/defines.h`中定义了`auto`，现在可以像C++11一样使用`auto`了。

* 我们注意到，有些同学在完成lab时遇到了一些奇怪的问题，这些问题其实编译器的warning已经有所提示，只是大家习惯于忽略warning。因此，我们修改了编译规则：**从lab2开始，所有warning将被视作error**。

* 更新了`linker.ld`、`init.h`、`init.c`和`CMakeLists.txt`，以防止定义的`init`函数在有些情况下被编译器优化掉，以及`.init`中的函数指针被错误对齐。（lab1中没有同学遇到过这个问题）

* 文档现在被放置于`doc`而非原来的`src/doc`目录下。

此外，我们撰写了一份API Reference供大家查阅实验框架中的接口。

## Physical Memory

`driver/memlayout.h`中给出了内存空间的布局，`EXTMEM`-`PHYSTOP`这段物理地址内的内存为可用的物理内存。考虑到我们的内核代码也要占用内存，实际可供分配的物理地址为`end`-`PHYSTOP`。

因为CPU开启了MMU，我们的代码里访问内存时，必须使用内核虚拟地址，不能直接使用物理地址。可以使用`aarch64/mmu.h`中定义的`K2P`宏将内核虚拟地址转换为物理地址，使用`P2K`将物理地址转换为内核虚拟地址。

## Allocator

就如我们在C中使用过的`malloc`和`free`一样，内存分配器用于为程序分配指定大小的内存块，并回收程序释放的内存块。因为指令集的限制，分配的内存块地址必须与大小对齐，即：如果需要分配的内存大小是2的倍数，则地址也要是2的倍数；如果大小是4的倍数，地址也要是4的倍数；如果大小是8的倍数，则地址也要是8的倍数。不需要16字节以上的对齐，请不要向下类推。

与C中的`free`相同，我们需要实现的内存分配器不要求程序在释放内存块时告知内存块的大小，所以你需要在合适的地方保存内存块大小。

<u>此外，我们保证助教直接提供或要求大家写的代码中需要通过内存分配器分配的内存大小均在`1`-`PAGE_SIZE/2`之间。</u>其中`PAGE_SIZE`是内存页的大小，定义在`aarch64/mmu.h`，我们暂时还不需要深入了解内存分页机制。

## 并发安全

本实验中，我们要求大家考虑并发安全问题。测试时，4个核会同时分配和释放内存，你编写的内存分配器必须考虑到这种情况。

如下面代码，我们希望这段代码找到处于`AVAILABLE`状态的元素，并将其标记为`USING`

```c
for (int i = 0; i < N; i++)
    if (mem[i] == AVAILABLE)
    {
        mem[i] = USING;
        return i;
    }
```

容易看出，当两个核同时执行这段代码时，可能两个核会返回同一个元素，导致重复分配。

解决并发问题的常用办法是为代码加锁，锁的设计保证同时只能有一个CPU取得锁，也就只能有一个CPU执行锁保护下的代码。

```c
acquire_spin_lock(mem_lock);
for (int i = 0; i < N; i++)
    if (mem[i] == AVAILABLE)
    {
        mem[i] = USING;
        return i;
    }
release_spin_lock(mem_lock);
```

另一种思路是为不同CPU维护不同的数据结构

```c
for (int i = 0; i < N; i++)
    if (mem[cpuid()][i] == AVAILABLE)
    {
        mem[cpuid()][i] = USING;
        return i;
    }
```

> 上面举例用的代码与本实验无关。

## <u>作业与提交</u>


